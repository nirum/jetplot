{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jetplot","text":"<p>Welcome to the jetplot documentation.</p>"},{"location":"#about","title":"About","text":"<p><code>jetplot</code> is a collection of miscellaneous utilities for Matplotlib that simplify creating rich visualizations and color palettes. It was created in 2015 by Niru Maheswaranathan.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jetplot\n</code></pre>"},{"location":"#changelog","title":"Changelog","text":"Version Release Date Description 0.6.0 Jul 21 2024 Migrated from setup.py to pyproject.toml. 0.5.3 Aug 30 2022 Stops jetplot from updating Matplotlib rcParams on import. 0.5.0 Jul 15 2022 Updates default color palettes, adds new Palette class, adds ridgeline plot. 0.4.0 Oct 20 2021 Name change! Package renamed to <code>jetplot</code>. 0.3.0 Oct 13 2021 Drops animation module and the <code>moviepy</code> dependency 0.0.0 Jan 19 2015 Initial commit"},{"location":"#license","title":"License","text":"<p>MIT. See <code>LICENSE.md</code></p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014-2022 Niru Maheswaranathan</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#list-of-modules","title":"List of modules","text":""},{"location":"description/","title":"Description","text":"<p><code>jetplot</code> provides helper functions for generating plots, color palettes, and simple signal utilities. The goal is to make it easier to produce publication quality figures with minimal code.</p> <p>Key modules include:</p> <ul> <li><code>colors</code>: utilities for working with custom color maps and palettes.</li> <li><code>plots</code>: common plot helpers like ridge lines and covariance ellipses.</li> <li><code>style</code>: helpers for configuring Matplotlib defaults.</li> <li><code>signals</code> and <code>timepiece</code>: basic signal processing and time utilities.</li> </ul>"},{"location":"api/chart_utils/","title":"chart_utils","text":"<p>Plotting utils.</p>"},{"location":"api/chart_utils/#jetplot.chart_utils.axwrapper","title":"<code>axwrapper(fun: Callable[..., Any]) -&gt; Callable[..., Any]</code>","text":"<p>Decorator that adds an axes handle to kwargs.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>def axwrapper(fun: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Decorator that adds an axes handle to kwargs.\"\"\"\n\n    @wraps(fun)\n    def wrapper(*args, **kwargs):\n        if \"ax\" not in kwargs:\n            if \"fig\" not in kwargs:\n                kwargs[\"fig\"] = plt.gcf()\n            kwargs[\"ax\"] = plt.gca()\n        else:\n            if \"fig\" not in kwargs:\n                kwargs[\"fig\"] = kwargs[\"ax\"].get_figure()\n        return fun(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.breathe","title":"<code>breathe(xlims: tuple[float, float] | None = None, ylims: tuple[float, float] | None = None, padding_percent: float = 0.05, **kwargs: Any) -&gt; plt.Axes</code>","text":"<p>Adds space between axes and plot.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>@axwrapper\ndef breathe(\n    xlims: tuple[float, float] | None = None,\n    ylims: tuple[float, float] | None = None,\n    padding_percent: float = 0.05,\n    **kwargs: Any,\n) -&gt; plt.Axes:\n    \"\"\"Adds space between axes and plot.\"\"\"\n    ax = kwargs[\"ax\"]\n\n    def identity(x):\n        return x\n\n    if ax.get_xscale() == \"log\":\n        xfwd = np.log10\n        xrev = partial(np.power, 10)\n    else:\n        xfwd = identity\n        xrev = identity\n\n    if ax.get_yscale() == \"log\":\n        yfwd = np.log10\n        yrev = partial(np.power, 10)\n    else:\n        yfwd = identity\n        yrev = identity\n\n    xmin, xmax = xfwd(ax.get_xlim()) if xlims is None else xlims\n    ymin, ymax = yfwd(ax.get_ylim()) if ylims is None else ylims\n\n    xdelta = (xmax - xmin) * padding_percent\n    ydelta = (ymax - ymin) * padding_percent\n\n    ax.set_xlim(xrev(xmin - xdelta), xrev(xmax + xdelta))\n    ax.spines[\"bottom\"].set_bounds(xrev(xmin), xrev(xmax))\n\n    ax.set_ylim(yrev(ymin - ydelta), yrev(ymax + ydelta))\n    ax.spines[\"left\"].set_bounds(yrev(ymin), yrev(ymax))\n\n    nospines(**kwargs)\n\n    return ax\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.figwrapper","title":"<code>figwrapper(fun: Callable[..., Any]) -&gt; Callable[..., Any]</code>","text":"<p>Decorator that adds figure handles to the kwargs of a function.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>def figwrapper(fun: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Decorator that adds figure handles to the kwargs of a function.\"\"\"\n\n    @wraps(fun)\n    def wrapper(*args, **kwargs):\n        if \"fig\" not in kwargs:\n            figsize = kwargs.get(\"figsize\", None)\n            kwargs[\"fig\"] = plt.figure(figsize=figsize)\n        return fun(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.get_bounds","title":"<code>get_bounds(axis: Literal['x', 'y'], ax: Axes | None = None) -&gt; tuple[float, float]</code>","text":"<p>Return the axis spine bounds for the given axis.</p>"},{"location":"api/chart_utils/#jetplot.chart_utils.get_bounds--parameters","title":"Parameters","text":"<p>axis : str     Axis to inspect, either <code>\"x\"</code> or <code>\"y\"</code>. ax : matplotlib.axes.Axes | None, optional     Axes object to inspect. If <code>None</code>, the current axes are used.</p>"},{"location":"api/chart_utils/#jetplot.chart_utils.get_bounds--returns","title":"Returns","text":"<p>tuple[float, float]     Lower and upper bounds of the axis spine.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>def get_bounds(axis: Literal[\"x\", \"y\"], ax: Axes | None = None) -&gt; tuple[float, float]:\n    \"\"\"Return the axis spine bounds for the given axis.\n\n    Parameters\n    ----------\n    axis : str\n        Axis to inspect, either ``\"x\"`` or ``\"y\"``.\n    ax : matplotlib.axes.Axes | None, optional\n        Axes object to inspect. If ``None``, the current axes are used.\n\n    Returns\n    -------\n    tuple[float, float]\n        Lower and upper bounds of the axis spine.\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n\n    axis_map: dict[str, Any] = {\n        \"x\": (ax.get_xticks, ax.get_xticklabels, ax.get_xlim, \"bottom\"),\n        \"y\": (ax.get_yticks, ax.get_yticklabels, ax.get_ylim, \"left\"),\n    }\n\n    # get functions\n    ticks, labels, limits, spine_key = axis_map[axis]\n\n    if ax.spines[spine_key].get_bounds():\n        return ax.spines[spine_key].get_bounds()\n    else:\n        lower, upper = None, None\n\n        for tick, label in zip(list(ticks()), list(labels()), strict=True):\n            if label.get_text() != \"\":\n                if lower is None:\n                    lower = tick\n                else:\n                    upper = tick\n\n        if lower is None or upper is None:\n            return limits()\n\n    return lower, upper\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.nospines","title":"<code>nospines(left: bool = False, bottom: bool = False, top: bool = True, right: bool = True, **kwargs: Any) -&gt; plt.Axes</code>","text":"<p>Hides the specified axis spines (by default, right and top spines)</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>@axwrapper\ndef nospines(\n    left: bool = False,\n    bottom: bool = False,\n    top: bool = True,\n    right: bool = True,\n    **kwargs: Any,\n) -&gt; plt.Axes:\n    \"\"\"\n    Hides the specified axis spines (by default, right and top spines)\n    \"\"\"\n\n    ax = kwargs[\"ax\"]\n\n    # assemble args into dict\n    disabled = dict(left=left, right=right, top=top, bottom=bottom)\n\n    # disable spines\n    for key in disabled:\n        if disabled[key]:\n            ax.spines[key].set_visible(False)\n\n    # disable xticks\n    if disabled[\"top\"] and disabled[\"bottom\"]:\n        ax.set_xticks([])\n    elif disabled[\"top\"]:\n        ax.xaxis.set_ticks_position(\"bottom\")\n    elif disabled[\"bottom\"]:\n        ax.xaxis.set_ticks_position(\"top\")\n\n    # disable yticks\n    if disabled[\"left\"] and disabled[\"right\"]:\n        ax.set_yticks([])\n    elif disabled[\"left\"]:\n        ax.yaxis.set_ticks_position(\"right\")\n    elif disabled[\"right\"]:\n        ax.yaxis.set_ticks_position(\"left\")\n\n    return ax\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.noticks","title":"<code>noticks(**kwargs: Any) -&gt; None</code>","text":"<p>Clears tick marks (useful for images)</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>@axwrapper\ndef noticks(**kwargs: Any) -&gt; None:\n    \"\"\"\n    Clears tick marks (useful for images)\n    \"\"\"\n\n    ax = kwargs[\"ax\"]\n    ax.set_xticks([])\n    ax.set_yticks([])\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.plotwrapper","title":"<code>plotwrapper(fun: Callable[..., Any]) -&gt; Callable[..., Any]</code>","text":"<p>Decorator that adds figure and axes handles to the kwargs of a function.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>def plotwrapper(fun: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Decorator that adds figure and axes handles to the kwargs of a function.\"\"\"\n\n    @wraps(fun)\n    def wrapper(*args, **kwargs):\n        if \"ax\" not in kwargs:\n            if \"fig\" not in kwargs:\n                figsize = kwargs.get(\"figsize\", None)\n                kwargs[\"fig\"] = plt.figure(figsize=figsize)\n            kwargs[\"ax\"] = kwargs[\"fig\"].add_subplot(111)\n        else:\n            if \"fig\" not in kwargs:\n                kwargs[\"fig\"] = kwargs[\"ax\"].get_figure()\n\n        return fun(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.xclamp","title":"<code>xclamp(x0: float | None = None, x1: float | None = None, dt: float | None = None, **kwargs: Any) -&gt; Axes</code>","text":"<p>Clamp the x-axis to evenly spaced tick marks.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>@axwrapper\ndef xclamp(\n    x0: float | None = None,\n    x1: float | None = None,\n    dt: float | None = None,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"Clamp the x-axis to evenly spaced tick marks.\"\"\"\n    ax = kwargs[\"ax\"]\n\n    lims = ax.get_xlim()\n    x0 = lims[0] if x0 is None else x0\n    x1 = lims[1] if x1 is None else x1\n\n    ticks: list[float] = ax.get_xticks()  # pyrefly: ignore\n    dt = float(np.mean(np.diff(ticks))) if dt is None else float(dt)\n\n    new_ticks = np.arange(dt * np.floor(x0 / dt), dt * (np.ceil(x1 / dt) + 1), dt)\n    ax.set_xticks(new_ticks)\n    ax.set_xticklabels(new_ticks)\n    ax.set_xlim(new_ticks[0], new_ticks[-1])\n\n    return ax\n</code></pre>"},{"location":"api/chart_utils/#jetplot.chart_utils.yclamp","title":"<code>yclamp(y0: float | None = None, y1: float | None = None, dt: float | None = None, **kwargs: Any) -&gt; Axes</code>","text":"<p>Clamp the y-axis to evenly spaced tick marks.</p> Source code in <code>src/jetplot/chart_utils.py</code> <pre><code>@axwrapper\ndef yclamp(\n    y0: float | None = None,\n    y1: float | None = None,\n    dt: float | None = None,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"Clamp the y-axis to evenly spaced tick marks.\"\"\"\n    ax = kwargs[\"ax\"]\n\n    lims = ax.get_ylim()\n    y0 = lims[0] if y0 is None else y0\n    y1 = lims[1] if y1 is None else y1\n\n    ticks: list[float] = ax.get_yticks()  # pyrefly: ignore\n    dt = float(np.mean(np.diff(ticks))) if dt is None else float(dt)\n\n    new_ticks = np.arange(dt * np.floor(y0 / dt), dt * (np.ceil(y1 / dt) + 1), dt)\n    ax.set_yticks(new_ticks)\n    ax.set_yticklabels(new_ticks)\n    ax.set_ylim(new_ticks[0], new_ticks[-1])\n\n    return ax\n</code></pre>"},{"location":"api/colors/","title":"colors","text":"<p>Colorschemes</p>"},{"location":"api/colors/#jetplot.colors.Palette","title":"<code>Palette</code>","text":"<p>               Bases: <code>list[ColorType]</code></p> <p>Color palette based on a list of values.</p> Source code in <code>src/jetplot/colors.py</code> <pre><code>class Palette(list[ColorType]):\n    \"\"\"Color palette based on a list of values.\"\"\"\n\n    @property\n    def hex(self) -&gt; \"Palette\":\n        \"\"\"Return the palette colors as hexadecimal strings.\"\"\"\n        return Palette([to_hex(rgb) for rgb in self])  # pyrefly: ignore\n\n    @property\n    def cmap(self) -&gt; LinearSegmentedColormap:\n        \"\"\"Return the palette as a Matplotlib colormap.\"\"\"\n        return LinearSegmentedColormap.from_list(\"\", self)\n\n    def plot(self, figsize: tuple[int, int] = (5, 1)) -&gt; tuple[Figure, list[Axes]]:\n        \"\"\"Visualize the colors in the palette.\"\"\"\n        fig, axs = plt.subplots(1, len(self), figsize=figsize)\n        for c, ax in zip(self, axs, strict=True):  # pyrefly: ignore\n            ax.set_facecolor(c)\n            ax.set_aspect(\"equal\")\n            noticks(ax=ax)\n\n        return fig, cast(list[Axes], axs)\n</code></pre>"},{"location":"api/colors/#jetplot.colors.Palette.cmap","title":"<code>cmap: LinearSegmentedColormap</code>  <code>property</code>","text":"<p>Return the palette as a Matplotlib colormap.</p>"},{"location":"api/colors/#jetplot.colors.Palette.hex","title":"<code>hex: Palette</code>  <code>property</code>","text":"<p>Return the palette colors as hexadecimal strings.</p>"},{"location":"api/colors/#jetplot.colors.Palette.plot","title":"<code>plot(figsize: tuple[int, int] = (5, 1)) -&gt; tuple[Figure, list[Axes]]</code>","text":"<p>Visualize the colors in the palette.</p> Source code in <code>src/jetplot/colors.py</code> <pre><code>def plot(self, figsize: tuple[int, int] = (5, 1)) -&gt; tuple[Figure, list[Axes]]:\n    \"\"\"Visualize the colors in the palette.\"\"\"\n    fig, axs = plt.subplots(1, len(self), figsize=figsize)\n    for c, ax in zip(self, axs, strict=True):  # pyrefly: ignore\n        ax.set_facecolor(c)\n        ax.set_aspect(\"equal\")\n        noticks(ax=ax)\n\n    return fig, cast(list[Axes], axs)\n</code></pre>"},{"location":"api/colors/#jetplot.colors.cmap_colors","title":"<code>cmap_colors(cmap: str, n: int, vmin: float = 0.0, vmax: float = 1.0) -&gt; Palette</code>","text":"<p>Extract <code>n</code> colors from a Matplotlib colormap.</p> Source code in <code>src/jetplot/colors.py</code> <pre><code>def cmap_colors(\n    cmap: str,\n    n: int,\n    vmin: float = 0.0,\n    vmax: float = 1.0,\n) -&gt; Palette:\n    \"\"\"Extract ``n`` colors from a Matplotlib colormap.\"\"\"\n    return Palette(getattr(cm, cmap)(np.linspace(vmin, vmax, n)))\n</code></pre>"},{"location":"api/colors/#jetplot.colors.cubehelix","title":"<code>cubehelix(n: int, vmin: float = 0.85, vmax: float = 0.15, gamma: float = 1.0, start: float = 0.0, rot: float = 0.4, hue: float = 0.8) -&gt; Palette</code>","text":"<p>Cubehelix parameterized colormap.</p> Source code in <code>src/jetplot/colors.py</code> <pre><code>def cubehelix(\n    n: int,\n    vmin: float = 0.85,\n    vmax: float = 0.15,\n    gamma: float = 1.0,\n    start: float = 0.0,\n    rot: float = 0.4,\n    hue: float = 0.8,\n) -&gt; Palette:\n    \"\"\"Cubehelix parameterized colormap.\"\"\"\n    lambda_ = np.linspace(vmin, vmax, n)\n    x = lambda_**gamma\n    phi = 2 * np.pi * (start / 3 + rot * lambda_)\n\n    alpha = 0.5 * hue * x * (1.0 - x)  # pyrefly: ignore\n    A = np.array([[-0.14861, 1.78277], [-0.29227, -0.90649], [1.97294, 0.0]])\n    b = np.stack([np.cos(phi), np.sin(phi)])\n\n    colors: list[tuple[float, float, float]] = (x + alpha * (A @ b)).T.tolist()\n    return Palette(colors)\n</code></pre>"},{"location":"api/colors/#jetplot.colors.rainbow","title":"<code>rainbow(k: int) -&gt; Palette</code>","text":"<p>Return a palette of distinct colors from several base palettes.</p> Source code in <code>src/jetplot/colors.py</code> <pre><code>def rainbow(k: int) -&gt; Palette:\n    \"\"\"Return a palette of distinct colors from several base palettes.\"\"\"\n\n    _colors = (\n        blue,\n        orange,\n        green,\n        red,\n        purple,\n        teal,\n        pink,\n        indigo,\n        emerald,\n        rose,\n        lime,\n        sky,\n        amber,\n    )\n    return Palette([r[k] for r in _colors])\n</code></pre>"},{"location":"api/images/","title":"images","text":"<p>Image visualization tools.</p>"},{"location":"api/images/#jetplot.images.cmat","title":"<code>cmat(arr: np.ndarray, labels: Iterable[str] | None = None, annot: bool = True, cmap: str = 'gist_heat_r', cbar: bool = False, fmt: str = '0.0%', dark_color: str = '#222222', light_color: str = '#dddddd', grid_color: str = cast(str, c.gray[9]), theta: float = 0.5, label_fontsize: float = 10.0, fontsize: float = 10.0, vmin: float = 0.0, vmax: float = 1.0, **kwargs: Any) -&gt; tuple[AxesImage, Axes]</code>","text":"<p>Plot confusion matrix.</p> Source code in <code>src/jetplot/images.py</code> <pre><code>@plotwrapper\ndef cmat(\n    arr: np.ndarray,\n    labels: Iterable[str] | None = None,\n    annot: bool = True,\n    cmap: str = \"gist_heat_r\",\n    cbar: bool = False,\n    fmt: str = \"0.0%\",\n    dark_color: str = \"#222222\",\n    light_color: str = \"#dddddd\",\n    grid_color: str = cast(str, c.gray[9]),\n    theta: float = 0.5,\n    label_fontsize: float = 10.0,\n    fontsize: float = 10.0,\n    vmin: float = 0.0,\n    vmax: float = 1.0,\n    **kwargs: Any,\n) -&gt; tuple[AxesImage, Axes]:\n    \"\"\"Plot confusion matrix.\"\"\"\n    num_rows, num_cols = arr.shape\n\n    ax = kwargs.pop(\"ax\")\n    cb = imv(arr, ax=ax, vmin=vmin, vmax=vmax, cmap=cmap, cbar=cbar)\n\n    xs, ys = np.meshgrid(np.arange(num_cols), np.arange(num_rows), indexing=\"xy\")\n\n    for x, y, value in zip(xs.flat, ys.flat, arr.flat, strict=True):  # pyrefly: ignore\n        color = dark_color if (value &lt;= theta) else light_color\n        label = f\"{{:{fmt}}}\".format(value)\n        ax.text(x, y, label, ha=\"center\", va=\"center\", color=color, fontsize=fontsize)\n\n    if labels is not None:\n        ax.set_xticks(np.arange(num_cols))\n        ax.set_xticklabels(labels, rotation=90, fontsize=label_fontsize)\n        ax.set_yticks(np.arange(num_rows))\n        ax.set_yticklabels(labels, fontsize=label_fontsize)\n\n    ax.xaxis.set_minor_locator(FixedLocator((np.arange(num_cols) - 0.5).tolist()))\n\n    ax.yaxis.set_minor_locator(FixedLocator((np.arange(num_rows) - 0.5).tolist()))\n\n    ax.grid(\n        visible=True,\n        which=\"minor\",\n        axis=\"both\",\n        linewidth=1.0,\n        color=grid_color,\n        linestyle=\"-\",\n        alpha=1.0,\n    )\n\n    return cb, ax\n</code></pre>"},{"location":"api/images/#jetplot.images.fsurface","title":"<code>fsurface(func: Callable[..., np.ndarray], xrng: tuple[float, float] | None = None, yrng: tuple[float, float] | None = None, n: int = 100, nargs: int = 2, **kwargs: Any) -&gt; None</code>","text":"<p>Plot a 2\u2011D function as a filled surface.</p> Source code in <code>src/jetplot/images.py</code> <pre><code>@plotwrapper\ndef fsurface(\n    func: Callable[..., np.ndarray],\n    xrng: tuple[float, float] | None = None,\n    yrng: tuple[float, float] | None = None,\n    n: int = 100,\n    nargs: int = 2,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Plot a 2\u2011D function as a filled surface.\"\"\"\n    xrng = (-1, 1) if xrng is None else xrng\n    yrng = xrng if yrng is None else yrng\n\n    xs = np.linspace(xrng[0], xrng[1], n)\n    ys = np.linspace(yrng[0], yrng[1], n)\n\n    xm, ym = np.meshgrid(xs, ys)\n\n    if nargs == 1:\n        zz = np.vstack([xm.ravel(), ym.ravel()])\n        args = (zz,)\n    elif nargs == 2:\n        args = (xm.ravel(), ym.ravel())\n    else:\n        raise ValueError(f\"Invalid value for nargs ({nargs})\")\n\n    zm = func(*args).reshape(xm.shape)\n\n    kwargs[\"ax\"].contourf(xm, ym, zm)\n</code></pre>"},{"location":"api/images/#jetplot.images.img","title":"<code>img(data: np.ndarray, mode: str = 'div', cmap: str | None = None, aspect: str = 'equal', vmin: float | None = None, vmax: float | None = None, cbar: bool = True, interpolation: str = 'none', **kwargs: Any) -&gt; AxesImage</code>","text":"<p>Visualize a matrix as an image.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <p>array_like, The array to visualize.</p> required <code>mode</code> <code>str</code> <p>string, One of 'div' for a diverging image, 'seq' for sequential, 'cov' for covariance matrices, or 'corr' for correlation matrices (default: 'div').</p> <code>'div'</code> <code>cmap</code> <code>str | None</code> <p>string, Colormap to use.</p> <code>None</code> <code>aspect</code> <code>str</code> <p>string, Either 'equal' or 'auto'</p> <code>'equal'</code> Source code in <code>src/jetplot/images.py</code> <pre><code>@plotwrapper\ndef img(\n    data: np.ndarray,\n    mode: str = \"div\",\n    cmap: str | None = None,\n    aspect: str = \"equal\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    cbar: bool = True,\n    interpolation: str = \"none\",\n    **kwargs: Any,\n) -&gt; AxesImage:\n    \"\"\"Visualize a matrix as an image.\n\n    Args:\n      img: array_like, The array to visualize.\n      mode: string, One of 'div' for a diverging image, 'seq' for\n        sequential, 'cov' for covariance matrices, or 'corr' for\n        correlation matrices (default: 'div').\n      cmap: string, Colormap to use.\n      aspect: string, Either 'equal' or 'auto'\n    \"\"\"\n    # work with a copy of the original image data\n    img = np.squeeze(data.copy())\n\n    # image bounds\n    img_min = np.min(img)\n    img_max = np.max(img)\n    abs_max = np.max(np.abs(img))\n\n    if mode == \"div\":\n        if vmin is None:\n            vmin = -abs_max\n        if vmax is None:\n            vmax = abs_max\n        if cmap is None:\n            cmap = \"seismic\"\n    elif mode == \"seq\":\n        if vmin is None:\n            vmin = img_min\n        if vmax is None:\n            vmax = img_max\n        if cmap is None:\n            cmap = \"viridis\"\n    elif mode == \"cov\":\n        vmin, vmax, cmap, cbar = 0, 1, \"viridis\", True\n    elif mode == \"corr\":\n        vmin, vmax, cmap, cbar = -1, 1, \"seismic\", True\n    else:\n        raise ValueError(\"Unrecognized mode: '\" + mode + \"'\")\n\n    # make the image\n    im = kwargs[\"ax\"].imshow(\n        img, cmap=cmap, interpolation=interpolation, vmin=vmin, vmax=vmax, aspect=aspect\n    )\n\n    # colorbar\n    if cbar:\n        plt.colorbar(im)\n\n    # clear ticks\n    noticks(ax=kwargs[\"ax\"])\n\n    return im\n</code></pre>"},{"location":"api/plots/","title":"plots","text":"<p>Common plots.</p>"},{"location":"api/plots/#jetplot.plots.bar","title":"<code>bar(labels: Sequence[str], data: Sequence[float], color: ColorType = '#888888', width: float = 0.7, offset: float = 0.0, err: Sequence[float] | None = None, capsize: float = 5, capthick: float = 2, **kwargs: Any) -&gt; Axes</code>","text":"<p>Bar chart.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>Sequence[str]</code> <p>list or iterable of text labels</p> required <code>data</code> <code>Sequence[float]</code> <p>list or iterable of numerical values to plot</p> required <code>color</code> <code>ColorType</code> <p>color of the bars (default: #888888)</p> <code>'#888888'</code> <code>width</code> <code>float</code> <p>width of the bars (default: 0.7)</p> <code>0.7</code> <code>err</code> <code>Sequence[float] | None</code> <p>list or iterable of error bar values (default: None)</p> <code>None</code> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef bar(\n    labels: Sequence[str],\n    data: Sequence[float],\n    color: ColorType = \"#888888\",\n    width: float = 0.7,\n    offset: float = 0.0,\n    err: Sequence[float] | None = None,\n    capsize: float = 5,\n    capthick: float = 2,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"Bar chart.\n\n    Args:\n      labels: list or iterable of text labels\n      data: list or iterable of numerical values to plot\n      color: color of the bars (default: #888888)\n      width: width of the bars (default: 0.7)\n      err: list or iterable of error bar values (default: None)\n    \"\"\"\n    ax = kwargs[\"ax\"]\n\n    n = len(data)\n    x = np.arange(n) + width\n    if err is not None:\n        err = np.vstack((np.zeros_like(err), err))  # pyrefly: ignore\n\n    ax.bar(x, data, width, color=color)\n\n    if err is not None:\n        caplines = ax.errorbar(\n            x,\n            data,\n            err,\n            capsize=capsize,\n            capthick=capthick,\n            fmt=\"none\",\n            marker=None,\n            color=color,\n        )[1]\n        caplines[0].set_markeredgewidth(0)\n\n    ax.set_xticks(x - offset)\n    ax.set_xticklabels(labels)\n\n    nospines(ax=ax)\n    ax.tick_params(axis=\"x\", length=0)\n    ax.spines[\"bottom\"].set_color(\"none\")\n    ax.set_xlim((0 - offset, n + width + offset))\n\n    return ax\n</code></pre>"},{"location":"api/plots/#jetplot.plots.circle","title":"<code>circle(radius: float = 1.0, **kwargs: Any) -&gt; None</code>","text":"<p>Plots a unit circle.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef circle(radius: float = 1.0, **kwargs: Any) -&gt; None:\n    \"\"\"Plots a unit circle.\"\"\"\n    ax = kwargs[\"ax\"]\n    theta = np.linspace(0, 2 * np.pi, 1001)\n    ax.plot(radius * np.cos(theta), radius * np.sin(theta), \"-\")\n</code></pre>"},{"location":"api/plots/#jetplot.plots.ellipse","title":"<code>ellipse(x: NDArray[np.floating], y: NDArray[np.floating], n_std: float = 3.0, facecolor: str = 'none', estimator: str = 'empirical', **kwargs: Any) -&gt; Ellipse</code>","text":"<p>Create a plot of the covariance confidence ellipse of x and y.</p>"},{"location":"api/plots/#jetplot.plots.ellipse--parameters","title":"Parameters","text":"<p>x, y : array-like, shape (n, )     Input data.</p> float <p>The number of standard deviations to determine the ellipse's radiuses.</p> <p>**kwargs     Forwarded to <code>~matplotlib.patches.Ellipse</code></p>"},{"location":"api/plots/#jetplot.plots.ellipse--returns","title":"Returns","text":"<p>matplotlib.patches.Ellipse</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef ellipse(\n    x: NDArray[np.floating],\n    y: NDArray[np.floating],\n    n_std: float = 3.0,\n    facecolor: str = \"none\",\n    estimator: str = \"empirical\",\n    **kwargs: Any,\n) -&gt; Ellipse:\n    \"\"\"\n    Create a plot of the covariance confidence ellipse of *x* and *y*.\n\n    Parameters\n    ----------\n    x, y : array-like, shape (n, )\n        Input data.\n\n    n_std : float\n        The number of standard deviations to determine the ellipse's radiuses.\n\n    **kwargs\n        Forwarded to `~matplotlib.patches.Ellipse`\n\n    Returns\n    -------\n    matplotlib.patches.Ellipse\n    \"\"\"\n    ax = cast(Axes, kwargs.get(\"ax\"))\n\n    if x.size != y.size:\n        raise ValueError(\"x and y must be the same size\")\n\n    # cov = np.cov(x, y)\n    pts = np.vstack((x, y)).T\n    Estimator = MinCovDet if estimator == \"robust\" else EmpiricalCovariance\n    cov = Estimator().fit(pts).covariance_\n\n    pearson = cov[0, 1] / np.sqrt(cov[0, 0] * cov[1, 1])\n    # Using a special case to obtain the eigenvalues of this\n    # two-dimensional dataset.\n    ell_radius_x = np.sqrt(1 + pearson)\n    ell_radius_y = np.sqrt(1 - pearson)\n    ellipse = Ellipse(\n        (0, 0),\n        width=ell_radius_x * 2,\n        height=ell_radius_y * 2,\n        facecolor=facecolor,\n        **kwargs,\n    )\n\n    # Calculating the standard deviation of x from\n    # the square root of the variance and multiplying\n    # with the given number of standard deviations.\n    scale_x = np.sqrt(cov[0, 0]) * n_std\n    mean_x = np.mean(x)  # pyrefly: ignore\n\n    # calculating the standard deviation of y ...\n    scale_y = np.sqrt(cov[1, 1]) * n_std\n    mean_y = np.mean(y)  # pyrefly: ignore\n\n    transform = (\n        Affine2D()\n        .rotate_deg(45)\n        .scale(float(scale_x), float(scale_y))\n        .translate(float(mean_x), float(mean_y))\n    )\n\n    ellipse.set_transform(transform + ax.transData)  # pyrefly: ignore\n    return ax.add_patch(ellipse)\n</code></pre>"},{"location":"api/plots/#jetplot.plots.errorplot","title":"<code>errorplot(x: NDArray[np.floating], y: NDArray[np.floating], yerr: NDArray[np.floating] | float | tuple[NDArray[np.floating], NDArray[np.floating]], method: str = 'patch', color: ColorType = '#222222', xscale: str = 'linear', fmt: str = '-', err_color: ColorType = '#cccccc', alpha_fill: float = 1.0, clip_on: bool = True, **kwargs: Any) -&gt; None</code>","text":"<p>Plot a line with error bars.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef errorplot(\n    x: NDArray[np.floating],\n    y: NDArray[np.floating],\n    yerr: NDArray[np.floating]\n    | float\n    | tuple[NDArray[np.floating], NDArray[np.floating]],\n    method: str = \"patch\",\n    color: ColorType = \"#222222\",\n    xscale: str = \"linear\",\n    fmt: str = \"-\",\n    err_color: ColorType = \"#cccccc\",\n    alpha_fill: float = 1.0,\n    clip_on: bool = True,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Plot a line with error bars.\"\"\"\n    ax = kwargs[\"ax\"]\n\n    if np.isscalar(yerr) or len(yerr) == len(y):  # pyrefly: ignore\n        ymin = y - yerr  # pyrefly: ignore\n        ymax = y + yerr  # pyrefly: ignore\n    elif len(yerr) == 2:\n        ymin, ymax = yerr  # pyrefly: ignore\n    else:\n        raise ValueError(\"Invalid yerr value: \", yerr)\n\n    if method == \"line\":\n        ax.plot(x, y, fmt, color=color, linewidth=4, clip_on=clip_on)\n        ax.plot(x, ymax, \"_\", ms=20, color=err_color, clip_on=clip_on)\n        ax.plot(x, ymin, \"_\", ms=20, color=err_color, clip_on=clip_on)\n\n        # plot error bars\n        for i, xi in enumerate(x):  # pyrefly: ignore\n            ax.plot(\n                np.array([xi, xi]),\n                np.array([ymin[i], ymax[i]]),\n                \"-\",\n                color=err_color,\n                linewidth=2,\n                clip_on=clip_on,\n            )\n\n    elif method == \"patch\":\n        ax.fill_between(\n            x,\n            ymin,\n            ymax,\n            color=err_color,\n            alpha=alpha_fill,\n            interpolate=True,\n            lw=0.0,\n            clip_on=clip_on,\n        )\n        ax.plot(x, y, fmt, color=color, clip_on=clip_on)\n\n    else:\n        raise ValueError(\"Method must be 'line' or 'patch'\")\n\n    ax.set_xscale(xscale)\n</code></pre>"},{"location":"api/plots/#jetplot.plots.hist","title":"<code>hist(*args: Any, histtype='stepfilled', alpha=0.85, density=True, **kwargs: Any) -&gt; Any</code>","text":"<p>Wrapper for matplotlib.hist function.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef hist(\n    *args: Any, histtype=\"stepfilled\", alpha=0.85, density=True, **kwargs: Any\n) -&gt; Any:\n    \"\"\"Wrapper for matplotlib.hist function.\"\"\"\n    ax = kwargs.pop(\"ax\")\n    kwargs.pop(\"fig\")\n\n    return ax.hist(*args, histtype=histtype, alpha=alpha, density=density, **kwargs)\n</code></pre>"},{"location":"api/plots/#jetplot.plots.hist2d","title":"<code>hist2d(x: NDArray[np.floating], y: NDArray[np.floating], bins: int | Sequence[float] | None = None, limits: NDArray[np.floating] | Sequence[Sequence[float]] | None = None, cmap: str = 'hot', **kwargs: Any) -&gt; None</code>","text":"<p>Visualizes a 2D histogram by binning data.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[floating]</code> <p>The x-value of the data points to bin.</p> required <code>y</code> <code>NDArray[floating]</code> <p>The y-value of the data points to bin.</p> required <code>bins</code> <code>int | Sequence[float] | None</code> <p>Either the number of bins to use, or the actual bin edges to use.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>A matplotlib colormap to use.</p> <code>'hot'</code> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef hist2d(\n    x: NDArray[np.floating],\n    y: NDArray[np.floating],\n    bins: int | Sequence[float] | None = None,\n    limits: NDArray[np.floating] | Sequence[Sequence[float]] | None = None,\n    cmap: str = \"hot\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Visualizes a 2D histogram by binning data.\n\n    Args:\n      x: The x-value of the data points to bin.\n      y: The y-value of the data points to bin.\n      bins: Either the number of bins to use, or the actual bin edges to use.\n      cmap: A matplotlib colormap to use.\n    \"\"\"\n\n    # parse inputs\n    if limits is None:\n        limits = np.array([[np.min(x), np.max(x)], [np.min(y), np.max(y)]])\n\n    if bins is None:\n        bins = 25\n\n    # compute the histogram\n    # pyrefly: ignore  # no-matching-overload, bad-argument-type\n    cnt, xe, ye = np.histogram2d(x, y, bins=bins, range=limits, density=True)\n\n    # generate the plot\n    ax = kwargs[\"ax\"]\n    ax.pcolor(xe, ye, cnt.T, cmap=cmap)\n    ax.set_xlim(xe[0], xe[-1])\n    ax.set_ylim(ye[0], ye[-1])\n    ax.set_aspect(\"equal\")\n</code></pre>"},{"location":"api/plots/#jetplot.plots.lines","title":"<code>lines(x: NDArray[np.floating] | NDArray[np.integer], lines: list[NDArray[np.floating]] | None = None, cmap: str = 'viridis', **kwargs) -&gt; Axes</code>","text":"<p>Plot multiple lines using a color map.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef lines(\n    x: NDArray[np.floating] | NDArray[np.integer],\n    lines: list[NDArray[np.floating]] | None = None,\n    cmap: str = \"viridis\",\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"Plot multiple lines using a color map.\"\"\"\n    ax = kwargs[\"ax\"]\n\n    if lines is None:\n        lines = list(x)  # pyrefly: ignore\n        x = np.arange(len(lines[0]))\n\n    else:\n        lines = list(lines)\n\n    colors = cmap_colors(cmap, len(lines))\n    for line, color in zip(lines, colors, strict=False):\n        ax.plot(x, line, color=color)\n\n    return ax\n</code></pre>"},{"location":"api/plots/#jetplot.plots.ridgeline","title":"<code>ridgeline(t: NDArray[np.floating], xs: Iterable[NDArray[np.floating]], colors: Iterable[ColorType], edgecolor: ColorType = '#ffffff', ymax: float = 0.6, **kwargs: Any) -&gt; tuple[Figure, list[Axes]]</code>","text":"<p>Stacked density plots reminiscent of a ridgeline plot.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@figwrapper\ndef ridgeline(\n    t: NDArray[np.floating],\n    xs: Iterable[NDArray[np.floating]],\n    colors: Iterable[ColorType],\n    edgecolor: ColorType = \"#ffffff\",\n    ymax: float = 0.6,\n    **kwargs: Any,\n) -&gt; tuple[Figure, list[Axes]]:\n    \"\"\"Stacked density plots reminiscent of a ridgeline plot.\"\"\"\n    fig = kwargs[\"fig\"]\n    axs = []\n\n    for k, (x, c) in enumerate(zip(xs, colors, strict=False)):\n        ax = fig.add_subplot(cast(int, len(xs)), 1, k + 1)\n        y = gaussian_kde(x).evaluate(t)\n        ax.fill_between(t, y, color=c, clip_on=False)\n        ax.plot(t, y, color=edgecolor, clip_on=False)\n        ax.axhline(0.0, lw=2, color=c, clip_on=False)\n\n        ax.set_xlim(t[0], t[-1])\n        ax.set_xticks([])\n        ax.set_xticklabels([])\n\n        ax.set_ylim(0.0, ymax)\n        ax.set_yticks([])\n        ax.set_yticklabels([])\n\n        nospines(ax=ax, left=True, bottom=True)\n        axs.append(ax)\n\n    return fig, axs\n</code></pre>"},{"location":"api/plots/#jetplot.plots.violinplot","title":"<code>violinplot(data: NDArray[np.floating], xs: Sequence[float] | float, fc: ColorType = neutral[3], ec: ColorType = neutral[9], mc: ColorType = neutral[1], showmedians: bool = True, showmeans: bool = False, showquartiles: bool = True, **kwargs: Any) -&gt; Axes</code>","text":"<p>Violin plot with customizable elements.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef violinplot(\n    data: NDArray[np.floating],\n    xs: Sequence[float] | float,\n    fc: ColorType = neutral[3],\n    ec: ColorType = neutral[9],\n    mc: ColorType = neutral[1],\n    showmedians: bool = True,\n    showmeans: bool = False,\n    showquartiles: bool = True,\n    **kwargs: Any,\n) -&gt; Axes:\n    \"\"\"Violin plot with customizable elements.\"\"\"\n    _ = kwargs.pop(\"fig\")\n    ax = kwargs.pop(\"ax\")\n\n    data = np.atleast_2d(data).T\n\n    if isinstance(xs, float) or isinstance(xs, int):\n        xs = [\n            xs,\n        ]\n\n    parts = ax.violinplot(\n        data, positions=xs, showmeans=False, showmedians=False, showextrema=False\n    )\n\n    for pc in parts[\"bodies\"]:\n        pc.set_facecolor(fc)\n        pc.set_edgecolor(ec)\n        pc.set_alpha(1.0)\n\n    # pyrefly: ignore  # no-matching-overload, bad-argument-type\n    q1, medians, q3 = np.percentile(data, [25, 50, 75], axis=0)\n\n    ax.vlines(\n        xs,\n        np.min(data, axis=0),\n        np.max(data, axis=0),\n        color=ec,\n        linestyle=\"-\",\n        lw=1,\n        zorder=10,\n        label=\"Extrema\",\n    )\n\n    if showquartiles:\n        ax.vlines(xs, q1, q3, color=ec, linestyle=\"-\", lw=5, zorder=5)\n\n    if showmedians:\n        ax.scatter(xs, medians, marker=\"o\", color=mc, s=15, zorder=20)\n\n    if showmeans:\n        ax.scatter(\n            xs,\n            # pyrefly: ignore  # no-matching-overload, bad-argument-type\n            np.mean(data, axis=0),\n            marker=\"s\",\n            color=mc,\n            s=15,\n            zorder=20,\n        )\n\n    return ax\n</code></pre>"},{"location":"api/plots/#jetplot.plots.waterfall","title":"<code>waterfall(x: NDArray[np.floating], ys: Iterable[NDArray[np.floating]], dy: float = 1.0, pad: float = 0.1, color: ColorType = '#444444', ec: ColorType = '#cccccc', ew: float = 2.0, **kwargs: Any) -&gt; None</code>","text":"<p>Waterfall plot.</p> Source code in <code>src/jetplot/plots.py</code> <pre><code>@plotwrapper\ndef waterfall(\n    x: NDArray[np.floating],\n    ys: Iterable[NDArray[np.floating]],\n    dy: float = 1.0,\n    pad: float = 0.1,\n    color: ColorType = \"#444444\",\n    ec: ColorType = \"#cccccc\",\n    ew: float = 2.0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Waterfall plot.\"\"\"\n    ax = kwargs[\"ax\"]\n    total = cast(int, len(ys))\n\n    for index, y in enumerate(ys):\n        zorder = total - index\n        y = y * dy + index\n        ax.plot(x, y + pad, color=ec, clip_on=False, lw=ew, zorder=zorder)\n        ax.fill_between(x, y, index, color=color, zorder=zorder, clip_on=False)\n\n    ax.set_ylim(0, total)\n    ax.set_xlim(x[0], x[-1])\n</code></pre>"},{"location":"api/signals/","title":"signals","text":"<p>Tools for signal processing.</p>"},{"location":"api/signals/#jetplot.signals.canoncorr","title":"<code>canoncorr(X: FloatArray, Y: FloatArray) -&gt; FloatArray</code>","text":"<p>Canonical correlation between two subspaces.</p> <p>Parameters:</p> Name Type Description Default <code>X,</code> <code>Y</code> <p>The subspaces to compare. They should be of the same size.</p> required <p>Returns:</p> Name Type Description <code>corr</code> <code>FloatArray</code> <p>array_like, Cosine of the principal angles.</p> Notes <p>The canonical correlation between subspaces generalizes the idea of the angle between vectors to linear subspaces. It is defined as recursively finding unit vectors in each subspace that are maximally correlated [1]. Here, we compute the principal vectors and angles via the QR decomposition [2].</p> References <p>.. [1] Angles between flats. (2016, August 4). In Wikipedia, The Free Encyclopedia  https://en.wikipedia.org/w/index.php?title=Angles_between_flats .. [2] Bj\u00f6rck, \u0226ke, and Gene H. Golub. \"Numerical methods for computing angles  between linear subspaces.\" Mathematics of computation 27.123 (1973): 579-594.</p> Source code in <code>src/jetplot/signals.py</code> <pre><code>def canoncorr(X: FloatArray, Y: FloatArray) -&gt; FloatArray:\n    \"\"\"Canonical correlation between two subspaces.\n\n    Args:\n      X, Y: The subspaces to compare. They should be of the same size.\n\n    Returns:\n      corr: array_like, Cosine of the principal angles.\n\n    Notes:\n      The canonical correlation between subspaces generalizes the idea of the angle\n      between vectors to linear subspaces. It is defined as recursively finding unit\n      vectors in each subspace that are maximally correlated [1]_. Here, we compute\n      the principal vectors and angles via the QR decomposition [2]_.\n\n    References:\n      .. [1] Angles between flats. (2016, August 4). In Wikipedia, The Free Encyclopedia\n       https://en.wikipedia.org/w/index.php?title=Angles_between_flats\n      .. [2] Bj\u00f6rck, \u0226ke, and Gene H. Golub. \"Numerical methods for computing angles\n       between linear subspaces.\" Mathematics of computation 27.123 (1973): 579-594.\n    \"\"\"\n    # Orthogonalize each subspace\n    # pyrefly: ignore  # no-matching-overload, bad-argument-type\n    Qx, _ = np.linalg.qr(X, mode=\"reduced\")\n    # pyrefly: ignore  # no-matching-overload, bad-argument-type\n    Qy, _ = np.linalg.qr(Y, mode=\"reduced\")\n\n    # singular values of the inner product between the orthogonalized spaces\n    return np.linalg.svd(Qx.T @ Qy, compute_uv=False)\n</code></pre>"},{"location":"api/signals/#jetplot.signals.normalize","title":"<code>normalize(X: ArrayLike, axis: int = -1, norm: NormFunction = np.linalg.norm) -&gt; NDArray[np.floating]</code>","text":"<p>Normalizes elements of an array or matrix.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ArrayLike</code> <p>The set of arrays to normalize.</p> required <code>axis</code> <code>int</code> <p>The axis along which to compute the norm (Default: -1).</p> <code>-1</code> <code>norm</code> <code>NormFunction</code> <p>Function that computes the norm (Default: np.linalg.norm).</p> <code>norm</code> <p>Returns:</p> Name Type Description <code>Xn</code> <code>NDArray[floating]</code> <p>Arrays that have been normalized using to the given function.</p> Source code in <code>src/jetplot/signals.py</code> <pre><code>def normalize(\n    X: ArrayLike, axis: int = -1, norm: NormFunction = np.linalg.norm\n) -&gt; NDArray[np.floating]:\n    \"\"\"Normalizes elements of an array or matrix.\n\n    Args:\n        X: The set of arrays to normalize.\n        axis: The axis along which to compute the norm (Default: -1).\n        norm: Function that computes the norm (Default: np.linalg.norm).\n\n    Returns:\n        Xn: Arrays that have been normalized using to the given function.\n    \"\"\"\n    return np.asarray(X) / norm(X, axis=axis, keepdims=True)\n</code></pre>"},{"location":"api/signals/#jetplot.signals.participation_ratio","title":"<code>participation_ratio(C: np.ndarray) -&gt; float</code>","text":"<p>Compute the participation ratio of a square matrix.</p> Source code in <code>src/jetplot/signals.py</code> <pre><code>def participation_ratio(C: np.ndarray) -&gt; float:\n    \"\"\"Compute the participation ratio of a square matrix.\"\"\"\n\n    if C.ndim != 2:\n        raise ValueError(\"C must be a matrix\")\n\n    if C.shape[0] != C.shape[1]:\n        raise ValueError(\"C must be a square matrix\")\n\n    diag_sum = float(np.trace(C))\n    diag_sq_sum = float(np.trace(C @ C))\n    return diag_sum**2 / diag_sq_sum\n</code></pre>"},{"location":"api/signals/#jetplot.signals.smooth","title":"<code>smooth(x: ArrayLike, sigma: float = 1.0, axis: int = 0) -&gt; NDArray[np.floating]</code>","text":"<p>Smooths a 1D signal with a gaussian filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ArrayLike</code> <p>array_like, The array to be smoothed</p> required <code>sigma</code> <code>float</code> <p>float, The width of the gaussian filter (default: 1.0)</p> <code>1.0</code> <p>Returns: xs: array_like, A smoothed version of the input signal</p> Source code in <code>src/jetplot/signals.py</code> <pre><code>def smooth(x: ArrayLike, sigma: float = 1.0, axis: int = 0) -&gt; NDArray[np.floating]:\n    \"\"\"Smooths a 1D signal with a gaussian filter.\n\n    Args:\n      x: array_like, The array to be smoothed\n      sigma: float, The width of the gaussian filter (default: 1.0)\n\n    Returns:\n    xs: array_like, A smoothed version of the input signal\n    \"\"\"\n    return gaussian_filter1d(x, sigma, axis=axis)\n</code></pre>"},{"location":"api/signals/#jetplot.signals.stable_rank","title":"<code>stable_rank(X: NDArray[np.floating[Any]]) -&gt; float</code>","text":"<p>Computes the stable rank of a matrix</p> Source code in <code>src/jetplot/signals.py</code> <pre><code>def stable_rank(X: NDArray[np.floating[Any]]) -&gt; float:\n    \"\"\"Computes the stable rank of a matrix\"\"\"\n    assert X.ndim == 2, \"X must be a matrix\"\n\n    # pyrefly: ignore\n    svals_sq = np.linalg.svd(X, compute_uv=False, full_matrices=False) ** 2\n\n    return svals_sq.sum() / svals_sq.max()\n</code></pre>"},{"location":"api/style/","title":"style","text":"<p>Opinionated matplotlib style defaults.</p>"},{"location":"api/style/#jetplot.style.available_fonts","title":"<code>available_fonts() -&gt; list[str]</code>","text":"<p>Returns a list of available fonts.</p> Source code in <code>src/jetplot/style.py</code> <pre><code>def available_fonts() -&gt; list[str]:\n    \"\"\"Returns a list of available fonts.\"\"\"\n    return sorted(set([f.name for f in fm.fontManager.ttflist]))  # pyrefly: ignore\n</code></pre>"},{"location":"api/style/#jetplot.style.install_fonts","title":"<code>install_fonts(filepath: str) -&gt; None</code>","text":"<p>Installs .ttf fonts in the given folder.</p> Source code in <code>src/jetplot/style.py</code> <pre><code>def install_fonts(filepath: str) -&gt; None:\n    \"\"\"Installs .ttf fonts in the given folder.\"\"\"\n\n    original_fonts = set(available_fonts())\n    font_files = fm.findSystemFonts(fontpaths=[filepath])\n\n    for font_file in font_files:\n        fm.fontManager.addfont(font_file)  # pyrefly: ignore\n\n    new_fonts = set(available_fonts()) - original_fonts\n    if new_fonts:\n        print(f\"Added the following fonts: {', '.join(new_fonts)}\")\n    else:\n        print(\"No new fonts added.\")\n</code></pre>"},{"location":"api/style/#jetplot.style.set_colors","title":"<code>set_colors(bg: ColorType, fg: ColorType, text: ColorType) -&gt; None</code>","text":"<p>Set background/foreground colorscheme.</p> Source code in <code>src/jetplot/style.py</code> <pre><code>def set_colors(bg: ColorType, fg: ColorType, text: ColorType) -&gt; None:\n    \"\"\"Set background/foreground colorscheme.\"\"\"\n    rcParams.update(\n        {\n            \"figure.facecolor\": bg,\n            \"figure.edgecolor\": bg,\n            \"axes.facecolor\": bg,\n            \"savefig.facecolor\": bg,\n            \"savefig.edgecolor\": bg,\n            \"axes.edgecolor\": fg,\n            \"axes.labelcolor\": text,\n            \"xtick.color\": fg,\n            \"ytick.color\": fg,\n            \"legend.edgecolor\": fg,\n            \"grid.color\": fg,\n            \"text.color\": text,\n        }\n    )\n</code></pre>"},{"location":"api/style/#jetplot.style.set_defaults","title":"<code>set_defaults(*, bg: ColorType, fg: ColorType, text: ColorType, cycler_colors: c.Palette, defaults: Mapping[str, Any] = STYLE_DEFAULTS, font: str = 'Helvetica') -&gt; None</code>","text":"<p>Sets matplotlib defaults.</p> Source code in <code>src/jetplot/style.py</code> <pre><code>def set_defaults(\n    *,\n    bg: ColorType,\n    fg: ColorType,\n    text: ColorType,\n    cycler_colors: c.Palette,\n    defaults: Mapping[str, Any] = STYLE_DEFAULTS,\n    font: str = \"Helvetica\",\n) -&gt; None:\n    \"\"\"Sets matplotlib defaults.\"\"\"\n    rcParams.update(defaults)\n    set_colors(bg, fg, text)\n    rcParams[\"axes.prop_cycle\"] = cycler(color=cycler_colors)\n\n    try:\n        set_font(font)\n    except ValueError:\n        pass\n</code></pre>"},{"location":"api/style/#jetplot.style.set_dpi","title":"<code>set_dpi(dpi: int) -&gt; None</code>","text":"<p>Sets the figure DPI.</p> Source code in <code>src/jetplot/style.py</code> <pre><code>def set_dpi(dpi: int) -&gt; None:\n    \"\"\"Sets the figure DPI.\"\"\"\n    rcParams[\"figure.dpi\"] = dpi\n</code></pre>"},{"location":"api/style/#jetplot.style.set_font","title":"<code>set_font(fontname: str) -&gt; None</code>","text":"<p>Specifies the matplotlib default font.</p> Source code in <code>src/jetplot/style.py</code> <pre><code>def set_font(fontname: str) -&gt; None:\n    \"\"\"Specifies the matplotlib default font.\"\"\"\n\n    if fontname not in available_fonts():\n        raise ValueError(f\"Font {fontname} not found.\")\n\n    rcParams[\"font.family\"] = fontname\n</code></pre>"},{"location":"api/timepiece/","title":"timepiece","text":"<p>Utilities for dealing with time.</p>"},{"location":"api/timepiece/#jetplot.timepiece.Stopwatch","title":"<code>Stopwatch</code>","text":"<p>Simple timer utility for measuring code execution time.</p> Source code in <code>src/jetplot/timepiece.py</code> <pre><code>class Stopwatch:\n    \"\"\"Simple timer utility for measuring code execution time.\"\"\"\n\n    def __init__(self, name: str = \"\") -&gt; None:\n        self.name = name\n        self.start = time.perf_counter()\n        self.absolute_start = time.perf_counter()\n\n    def __str__(self) -&gt; str:\n        return \"\\u231a  Stopwatch for: \" + self.name\n\n    @property\n    def elapsed(self) -&gt; float:\n        current = time.perf_counter()\n        elapsed = current - self.start\n        self.start = time.perf_counter()\n        return elapsed\n\n    def checkpoint(self, name: str = \"\") -&gt; None:\n        print(f\"{self.name} {name} took {hrtime(self.elapsed)}\".strip())\n\n    def __enter__(self) -&gt; \"Stopwatch\":\n        return self\n\n    def __exit__(self, *_: object) -&gt; None:\n        total = hrtime(time.perf_counter() - self.absolute_start)\n        print(f\"{self.name} Finished! \\u2714\\nTotal elapsed time: {total}\")\n</code></pre>"},{"location":"api/timepiece/#jetplot.timepiece.hrtime","title":"<code>hrtime(t: float) -&gt; str</code>","text":"<p>Converts a time in seconds to a reasonable human readable time.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>float, Time in seconds.</p> required <p>Returns:</p> Name Type Description <code>time</code> <code>str</code> <p>string, Human readable formatted value of the given time.</p> Source code in <code>src/jetplot/timepiece.py</code> <pre><code>def hrtime(t: float) -&gt; str:\n    \"\"\"Converts a time in seconds to a reasonable human readable time.\n\n    Args:\n      t: float, Time in seconds.\n\n    Returns:\n      time: string, Human readable formatted value of the given time.\n    \"\"\"\n\n    # weeks\n    if t &gt;= 7 * 60 * 60 * 24:\n        weeks = np.floor(t / (7 * 60 * 60 * 24))\n        timestr = f\"{weeks:0.0f} weeks, \" + hrtime(t % (7 * 60 * 60 * 24))\n\n    # days\n    elif t &gt;= 60 * 60 * 24:\n        days = np.floor(t / (60 * 60 * 24))\n        timestr = f\"{days:0.0f} days, \" + hrtime(t % (60 * 60 * 24))\n\n    # hours\n    elif t &gt;= 60 * 60:\n        hours = np.floor(t / (60 * 60))\n        timestr = f\"{hours:0.0f} hours, \" + hrtime(t % (60 * 60))\n\n    # minutes\n    elif t &gt;= 60:\n        minutes = np.floor(t / 60)\n        timestr = f\"{minutes:0.0f} min., \" + hrtime(t % 60)\n\n    # seconds\n    elif (t &gt;= 1) | (t == 0):\n        timestr = f\"{t:g} s\"\n\n    # milliseconds\n    elif t &gt;= 1e-3:\n        timestr = f\"{t * 1e3:g} ms\"\n\n    # microseconds\n    elif t &gt;= 1e-6:\n        timestr = f\"{t * 1e6:g} \\u03bcs\"\n\n    # nanoseconds or smaller\n    else:\n        timestr = f\"{t * 1e9:g} ns\"\n\n    return timestr\n</code></pre>"},{"location":"api/timepiece/#jetplot.timepiece.profile","title":"<code>profile(func: Callable[..., Any]) -&gt; Callable[..., Any]</code>","text":"<p>Timing (profile) decorator for a function.</p> Source code in <code>src/jetplot/timepiece.py</code> <pre><code>def profile(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Timing (profile) decorator for a function.\"\"\"\n    calls = list()\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        tstart = time.perf_counter()\n        results = func(*args, **kwargs)\n        tstop = time.perf_counter()\n        calls.append(tstop - tstart)\n        return results\n\n    def mean() -&gt; float:\n        return float(np.mean(calls))\n\n    def serr() -&gt; float:\n        return float(np.std(calls) / np.sqrt(len(calls)))\n\n    def summary() -&gt; None:\n        print(f\"Runtimes: {hrtime(mean())} \\u00b1 {hrtime(serr())}\")\n\n    wrapper.__dict__[\"calls\"] = calls\n    wrapper.__dict__[\"mean\"] = mean\n    wrapper.__dict__[\"serr\"] = serr\n    wrapper.__dict__[\"summary\"] = summary\n\n    return wrapper\n</code></pre>"}]}